C00F 000		jump 	loop	jump to loop
0005 001 MAX	dw				int MAX = 5
003F 002 A		dw				int A[]
0000 003 temp	dw				temp used to swap
0000 004 i 		dw				iterator
0004 005 j 		dw				second iterator
3000 006 l		dw				load number in array
0000 007 A[j]	dw				store current
0000 008 A[j-1] dw				store previous
0001 009 one	dw				one
4000 00A s 		dw				store
0004 00B four	dw				int 4 for MAX -1
0000 00C 						leave space for changes
0000 00D
0000 00E
3001 00F loop	load	MAX		load max, begin first loop
6004 010 		sub		i 		subtract i
D03E 011		jumpe	xit		jump to xit if accumulator is zero (i == MAX)
E03E 012 		jumpl	xit		jump, accumulator is less than zero (i > MAX)
3005 013 nested	load	j 		load j, begin nested loop
6004 014		sub 	i 		subtract i
D038 015		jumpe	end		jump to end if accumulator is zero (j == i)
E038 016 		jumpl	end		jump, accumulator is less than zero (i > j)
3006 017		load	l 		load A[j]
5002 018		add		A 		add A to accumulator to get address of A[]
5005 019		add		j 		add j to accumulator to get address of A[j]
401B 01A		store	doit1	plant the instruction into the program
0000 01B doit1	dw				eventually will pull up A[j]
4007 01C 		store	A[j]	store A[j]
3006 01D		load	l 		load A[j-1]
5002 01E		add		A 		add A to accumulator to get address of A[]
5005 01F		add		j 		add j to accumulator to get address of A[j]
6009 020		sub 	one		subtract 1 to get address of A[j-1]
4022 021		store	doit2	plant the instruction into the program
0000 022 doit2	dw				eventually will pull up A[j-1]
4008 023 		store	A[j-1]	store A[j-1]
3008 024		load 	A[j-1]	load A[j-1]
6007 025 		sub 	A[j] 	subtract A[j] (if A[j] < A[j-1])
E034 026 		jmpl 	endl	jump to end of nested loop if A[j] is greater
300A 027		load	s 		load to store
5002 028		add 	A 		add A to accumulator to get address of A[]
5005 029		add 	j  		add j to accumulator to get address of A[j]
402C 02A		store   swap	plant the instruction into the program
3008 02B		load	A[j-1]	load A[j-1] to store into A[j]
0000 02C swap	dw				eventually swaps A[j] and A[j-1]
300A 02D		load	s 		load to store
5002 02E		add 	A 		add A to accumulator to get address of A[]
5005 02F		add 	j  		add j to accumulator to get address of A[j
6009 030		sub 	one		subtract 1 to get address of A[j-1]
4033 031		store	swap2	plant the instruction into the program
3007 032		load	A[j]	load A[j] to store into A[j-1]
0000 033 swap2	dw				eventually swaps A[j] and A[j-1]
3005 034 endl	load 	j 		load j
6009 035 		sub 	one		decrement j
4005 036 		store 	j 		store new j value
C013 037 		jmp 	nested 	jump to nested to restart
3004 038 end 	load 	i 		load i
5009 039 		add 	one 	increment i
4004 03A 		store   i 		store new i value
300B 03B 		load 	four	load four
4005 03C		store 	j 		reset value for j to 4
C00F 03D 		jmp 	loop    go through loop again
0000 03E xit	halt
0005 03F A[0]	dw				A[0] = 5
0004 040 A[1]	dw				A[1] = 4
0003 041 A[2]	dw				A[2] = 3
0002 042 A[3]	dw				A[3] = 2
0001 043 A[4] 	dw				A[4] = 1